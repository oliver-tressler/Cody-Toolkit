using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xrm.Sdk.Metadata;
using proxygenerator.Data.Model;
using proxygenerator.Data.Model.Attributes;
using proxygenerator.Generators.Contract;
using proxygenerator.Generators.CS.AttributeGenerators;
using proxygenerator.Generators.CS.CollectionFetcherGenerators.Concrete;
using proxygenerator.Generators.CS.PropertyGenerators.Concrete;
using proxygenerator.Utils;

namespace proxygenerator.Generators.CS.EntityGenerator
{
    public class EntityGenerator : IEntityGenerator
    {
        private readonly EntityData _data;
        private readonly string _proxyNamespace;

        private readonly List<string> _imports = new List<string>
        {
            "System",
            "System.Linq",
            "System.Collections.Generic",
            "Microsoft.Xrm.Sdk",
            "Microsoft.Xrm.Sdk.Query",
            "Microsoft.Crm.Sdk.Messages",
            "Microsoft.Xrm.Sdk.Messages",
            "Microsoft.Xrm.Sdk.Metadata",
            "Microsoft.Xrm.Sdk.Client",
            "System.Threading.Tasks",
            "System.ComponentModel",
            "System.Runtime.Serialization",
        };

        public EntityGenerator(EntityData data, string proxyNamespace)
        {
            _data = data;
            _proxyNamespace = proxyNamespace;
            foreach (var dataExternalOptionSet in data.ExternalOptionSets)
            {
                _imports.Add($"{dataExternalOptionSet.InternalEnumName} = {proxyNamespace}.Enums.{dataExternalOptionSet.ExposedEnumName}");
            }
            //imports.Add($"{_proxyNamespace}.Enums");
        }

        public string GenerateEntityCode()
        {
            var code = new StringBuilder();
            code.AppendLine("// <auto-generated />");
            code.AppendLine();
            GenerateImports(code);
            code.AppendLine();
            GenerateClassBody(code);
            return code.ToString();
        }

        private void GenerateImports(StringBuilder code)
        {
            foreach (var import in _imports)
                code.AppendLine(
                    $"using {import};");
        }


        private void GenerateClassBody(StringBuilder code)
        {

            code.AppendLine($"namespace " + _proxyNamespace);
            code.AppendLine("{");
            if (_data.ClassComment?.Generate == true)
                code.AppendLine(_data.ClassComment.GenerateComment(1));
            code.AppendLine($"{TextUtils.Indentation(1)}[EntityLogicalNameAttribute(\"{_data.LogicalName}\")]");
            code.AppendLine($"{TextUtils.Indentation(1)}[System.CodeDom.Compiler.GeneratedCodeAttribute(\"CrmTooling\", \"0.5\")]");
            code.AppendLine($"{TextUtils.Indentation(1)}[DataContract(Name = \"Entity\", Namespace = \"http://schemas.microsoft.com/xrm/2011/Contracts\")]");
            code.AppendLine($"{TextUtils.Indentation(1)}public partial class {_data.ClassName} : BaseProxyClass");
            code.AppendLine($"{TextUtils.Indentation(1)}{{");
            GenerateStaticMetadata(code, 2);
            code.AppendLine();
            GenerateConstructors(code, 2);
            code.AppendLine(GetUtilityCode(_data.ClassName));
            GenerateProperties(code, 2);
            code.AppendLine();
            GenerateCollectionFetchers(code, 2);
            code.AppendLine();
            GenerateIntersectFetchers(code, 2);
            code.AppendLine();
            GenerateOptionSets(code, 2);
            code.AppendLine();
            GenerateAttributes(code, 2);
            code.AppendLine($"{TextUtils.Indentation(1)}}}");
            code.AppendLine("}");
        }

        private void GenerateProperties(StringBuilder code, int indentationLevel)
        {
            var propertyCode = _data.Attributes.Where(a => a.Generate && a.Getter.Generate).Select(attribute =>
            {
                switch (attribute)
                {
                    case OptionSetAttributeData osaData:
                        return new OptionSetPropertyGenerator(osaData).GenerateAttributeProperties(indentationLevel);
                    case StringAttributeData stringAttributeData:
                        return new StringPropertyGenerator(stringAttributeData).GenerateAttributeProperties(indentationLevel);
                    case MoneyAttributeData moneyAttributeData:
                        return new MoneyPropertyGenerator(moneyAttributeData).GenerateAttributeProperties(indentationLevel);
                    case PrecisionNumericAttributeData precisionNumericAttributeData:
                        switch (precisionNumericAttributeData.AttributeTypeCode)
                        {
                            case (int)AttributeTypeCode.Decimal: return new DecimalPropertyGenerator(precisionNumericAttributeData).GenerateAttributeProperties(indentationLevel);
                            case (int)AttributeTypeCode.Double: return new DoublePropertyGenerator(precisionNumericAttributeData).GenerateAttributeProperties(indentationLevel);
                        }
                        return new DefaultPropertyGenerator(attribute).GenerateAttributeProperties(indentationLevel);
                    case NumericAttributeData numericAttributeData:
                        switch (numericAttributeData.AttributeTypeCode)
                        {
                            case (int)AttributeTypeCode.BigInt: return new LongPropertyGenerator(numericAttributeData).GenerateAttributeProperties(indentationLevel);
                            case (int)AttributeTypeCode.Integer: return new IntegerPropertyGenerator(numericAttributeData).GenerateAttributeProperties(indentationLevel);
                        }
                        return new DefaultPropertyGenerator(attribute).GenerateAttributeProperties(indentationLevel);
                    default:
                        return new DefaultPropertyGenerator(attribute).GenerateAttributeProperties(indentationLevel);
                }
            });
            code.AppendLine(string.Join(Environment.NewLine, propertyCode));
        }

        private void GenerateAttributes(StringBuilder code, int indentationLevel)
        {
            var i = TextUtils.Indentation(indentationLevel);
            var factory = new AttributeGeneratorFactory();
            code.AppendLine($"{i}public static class Properties");
            code.AppendLine($"{i}{{");
            var attributes = string.Join(Environment.NewLine, _data.Attributes.Where(a => a.Generate).Select(
                attribute => factory.GetGenerator(attribute).GenerateAttribute(indentationLevel + 1)));
            code.AppendLine(attributes);
            code.Append($"{i}}}");
        }

        private void GenerateConstructors(StringBuilder code, int indentationLevel)
        {
            var i = TextUtils.Indentation(indentationLevel);
            var i2 = TextUtils.Indentation(indentationLevel + 1);
            code.AppendLine($"{i}static {_data.ClassName}()");
            code.AppendLine($"{i}{{");
            code.AppendLine($"{i2}BaseProxyClass.RegisterProxyType(typeof({_data.ClassName}), \"{_data.LogicalName}\");");
            code.AppendLine($"{i2}_textOptions = new Dictionary<string, eTextOptions>();");
            code.AppendLine($"{i2}_numberOptions = new Dictionary<string, eNumberOptions>();");
            code.AppendLine($"{i2}_errorStrings = new Dictionary<string, string>();");
            code.AppendLine($"{i2}TextError = \"The value for attribute '{{0}}' cannot be longer than {{3}} characters. The length of the value is {{2}} characters.\";");
            code.AppendLine($"{i2}NumberError = \"The value for attribute '{{0}}' must be between {{2}} and {{3}}. The value is {{1}}\";");
            code.AppendLine($"{i}}}");
            code.AppendLine($"{i}public {_data.ClassName}() : base(new Entity(\"{_data.LogicalName}\")) {{ }}");
            code.AppendLine($"{i}public {_data.ClassName}(Entity original) : base(original) {{ }}");
        }

        private void GenerateStaticMetadata(StringBuilder sb, int indentationLevel)
        {
            var indent = TextUtils.Indentation(indentationLevel);
            sb.AppendLine($"{indent}public new const string LogicalName = \"{_data.LogicalName}\";");
            sb.AppendLine($"{indent}public const int ObjectTypeCode = {_data.ObjectTypeCode};");
            sb.AppendLine($"{indent}public const string PrimaryIdAttribute = \"{_data.PrimaryIdAttributeName}\";");
            sb.AppendLine($"{indent}public const string PrimaryNameAttribute = \"{_data.PrimaryNameAttributeName}\";");
        }

        private void GenerateOptionSets(StringBuilder code, int indentationLevel)
        {
            var i = TextUtils.Indentation(indentationLevel);
            var i1 = TextUtils.Indentation(indentationLevel + 1);
            foreach (var enumAttributeMetadata in _data.InternalOptionSets)
            {
                code.AppendLine($"{i}public enum {enumAttributeMetadata.InternalEnumName}");
                code.AppendLine($"{i}{{");
                code.AppendLine(string.Join($",{Environment.NewLine}",
                    enumAttributeMetadata.Options.Select(optionData =>
                        $"{optionData.Comment.GenerateXmlSummaryComment(indentationLevel + 1)}{Environment.NewLine}{i1}{optionData.OptionName} = {optionData.OptionValue}")));
                code.AppendLine($"{i}}}");
            }
        }

        private void GenerateCollectionFetchers(StringBuilder code, int indentationLevel)
        {
            code.AppendLine(string.Join(Environment.NewLine,
                _data.CollectionFetchers.Where(cf => cf.Generate).Select(cf => new DefaultCollectionFetcherGenerator(cf).GenerateCollectionFetcher(indentationLevel))));
        }

        private void GenerateIntersectFetchers(StringBuilder code, int indentationLevel)
        {
            code.AppendLine(string.Join(Environment.NewLine + Environment.NewLine,
                _data.IntersectFetchers.Where(intersectFetcher => intersectFetcher.Generate).Select(intersectFetcher =>
                    new IntersectCollectionFetcherGenerator(intersectFetcher)
                        .GenerateIntersectFetcher(indentationLevel))));
        }

        public IEnumerable<(string FileName, string Content)> GenerateExternalOptionSets()
        {
            var i1 = TextUtils.Indentation(1);
            var i2 = TextUtils.Indentation(2);
            var generatedOptionSets = new List<(string FileName, string Content)>(_data.ExternalOptionSets.Count);
            foreach (var optionSetData in _data.ExternalOptionSets)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"namespace {_proxyNamespace}.Enums");
                sb.AppendLine("{");
                sb.AppendLine($"{i1}public enum {optionSetData.EnumName}");
                sb.AppendLine($"{i1}{{");
                sb.AppendLine(string.Join($",{Environment.NewLine}",
                    optionSetData.Options.Select(
                        optionData => $"{optionData.Comment.GenerateXmlSummaryComment(2)}{Environment.NewLine}{i2}{optionData.OptionName} = {optionData.OptionValue}")));
                sb.AppendLine($"{i1}}}");
                sb.AppendLine("}");
                generatedOptionSets.Add((optionSetData.LogicalName, sb.ToString()));
            }

            return generatedOptionSets;
        }

        private string GetUtilityCode(string className) { return $@"
        public static string GetLogicalName() {{ return BaseProxyClass.GetLogicalName<{className}>(); }}
        /// <summary>
        /// Action to perform when the string value is greater than the allowed length.
        /// <para>This is the default for any string attribute in this Entity</para>
        /// </summary>
        public static eTextOptions TextOptions {{ get; set; }}
        private static Dictionary<string, eTextOptions> _textOptions;
        /// <summary>
        /// Use this to set an action and error string when a value is greater than the allowed length
        /// </summary>
        /// <param name=""logicalName"">Name of Attribute</param>
        /// <param name=""options"">Action to perform when the value is greater than the allowed length</param>
        /// <param name=""errorString"">Optional: Error to throw if the eTextOptions == ThrowError
        /// <para>If nothing is specified then the 'TextError' string is used.</para>
        /// <para>You may use the following parameters:</para>
        /// <para>{{0}} = Attribute Logical Name</para>
        /// <para>{{1}} = Value</para>
        /// <para>{{2}} = Length</para>
        /// <para>{{3}} = Max Length</para>
        /// </param>
        public static void SetTextOptions(string logicalName, eTextOptions options, string errorString = null)
        {{
            if (_textOptions.ContainsKey(logicalName)) {{ _textOptions[logicalName] = options; }}
            else {{ _textOptions.Add(logicalName, options); }}
            if (!string.IsNullOrEmpty(errorString))
            {{
                if (_errorStrings.ContainsKey(logicalName)) {{ _errorStrings[logicalName] = errorString; }}
                else {{ _errorStrings.Add(logicalName, errorString); }}
            }}
            else if (_errorStrings.ContainsKey(logicalName)) {{ _errorStrings.Remove(logicalName); }}
        }}
        protected override eTextOptions GetTextOptions(string logicalName)
        {{
            if (_textOptions.ContainsKey(logicalName)) {{ return _textOptions[logicalName]; }}
            return TextOptions;
        }}
        /// <summary>
        /// Action to perform when the number value is greater or less than the allowed value.
        /// <para>This is the default for any int, decimal, double, or money attribute in this Entity</para>
        /// </summary>
        public static eNumberOptions NumberOptions {{ get; set; }}
        private static Dictionary<string, eNumberOptions> _numberOptions;
        /// <summary>
        /// Use this to set an action and error string when a value is greater or less than the allowed value
        /// </summary>
        /// <param name=""logicalName"">Name of Attribute</param>
        /// <param name=""options"">Action to perform when the value is greater or less than the allowed value</param>
        /// <param name=""errorString"">Optional: Error to throw if the eNumberOptions == ThrowError
        /// <para>If nothing is specified then the 'NumberError' string is used.</para>
        /// <para>You may use the following parameters:</para>
        /// <para>{{0}} = Attribute Logical Name</para>
        /// <para>{{1}} = Value</para>
        /// <para>{{2}} = Min Value</para>
        /// <para>{{3}} = Max Value</para>
        /// </param>
        public static void SetNumberOptions(string logicalName, eNumberOptions options, string errorString = null)
        {{
            if (_numberOptions.ContainsKey(logicalName)) {{ _numberOptions[logicalName] = options; }}
            else {{ _numberOptions.Add(logicalName, options); }}
            if (!string.IsNullOrEmpty(errorString))
            {{
                if (_errorStrings.ContainsKey(logicalName)) {{ _errorStrings[logicalName] = errorString; }}
                else {{ _errorStrings.Add(logicalName, errorString); }}
            }}
            else if (_errorStrings.ContainsKey(logicalName)) {{ _errorStrings.Remove(logicalName); }}
        }}
        protected override eNumberOptions GetNumberOptions(string logicalName)
        {{
            if (_numberOptions.ContainsKey(logicalName)) {{ return _numberOptions[logicalName]; }}
            return NumberOptions;
        }}
        private static Dictionary<string, string> _errorStrings;
        protected override string GetErrorString(string attributeName, BaseProxyClass.eErrorType defaultErrorType)
        {{
            if (_errorStrings.ContainsKey(attributeName))
            {{
                return _errorStrings[attributeName];
            }}
            return defaultErrorType == BaseProxyClass.eErrorType.Text ? TextError : NumberError;
        }}
        /// <summary>
        /// <para>Default error string is: The value for attribute '{{0}}' cannot be longer than {{3}} characters. The length of the value is {{2}} characters.</para>
        /// <para>You may use the following parameters</para>
        /// <para>{{0}} = Attribute Name</para>
        /// <para>{{1}} = Value</para>
        /// <para>{{2}} = Length</para>
        /// <para>{{3}} = Max Length</para>
        /// </summary>
        public static string TextError {{ get; set; }}
        /// <summary>
        /// <para>Default error string is: The value for attribute '{{0}}' must be between {{2}} and {{3}}. The value is {{1}}.</para>
        /// <para>You may use the following parameters</para>
        /// <para>{{0}} = Attribute Name</para>
        /// <para>{{1}} = Value</para>
        /// <para>{{2}} = Min Value</para>
        /// <para>{{3}} = Max Value</para>
        /// </summary>
        public static string NumberError {{ get; set; }}

        ///<summary>";
        }
    }
}